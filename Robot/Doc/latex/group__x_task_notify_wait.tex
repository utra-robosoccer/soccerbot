\hypertarget{group__x_task_notify_wait}{}\section{x\+Task\+Notify\+Wait}
\label{group__x_task_notify_wait}\index{x\+Task\+Notify\+Wait@{x\+Task\+Notify\+Wait}}
task. h 
\begin{DoxyPre}BaseType\_t xTaskNotifyWait( uint32\_t ulBitsToClearOnEntry, uint32\_t ulBitsToClearOnExit, uint32\_t *pulNotificationValue, TickType\_t xTicksToWait );\end{DoxyPre}


config\+U\+S\+E\+\_\+\+T\+A\+S\+K\+\_\+\+N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+O\+NS must be undefined or defined as 1 for this function to be available.

When config\+U\+S\+E\+\_\+\+T\+A\+S\+K\+\_\+\+N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+O\+NS is set to one each task has its own private \char`\"{}notification value\char`\"{}, which is a 32-\/bit unsigned integer (uint32\+\_\+t).

Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.

A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task\textquotesingle{}s notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.

A notification sent to a task will remain pending until it is cleared by the task calling x\+Task\+Notify\+Wait() or ul\+Task\+Notify\+Take(). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.

A task can use x\+Task\+Notify\+Wait() to \mbox{[}optionally\mbox{]} block to wait for a notification to be pending, or ul\+Task\+Notify\+Take() to \mbox{[}optionally\mbox{]} block to wait for its notification value to have a non-\/zero value. The task does not consume any C\+PU time while it is in the Blocked state.

See \href{http://www.FreeRTOS.org/RTOS-task-notifications.html}{\tt http\+://www.\+Free\+R\+T\+O\+S.\+org/\+R\+T\+O\+S-\/task-\/notifications.\+html} for details.


\begin{DoxyParams}{Parameters}
{\em ul\+Bits\+To\+Clear\+On\+Entry} & Bits that are set in ul\+Bits\+To\+Clear\+On\+Entry value will be cleared in the calling task\textquotesingle{}s notification value before the task checks to see if any notifications are pending, and optionally blocks if no notifications are pending. Setting ul\+Bits\+To\+Clear\+On\+Entry to U\+L\+O\+N\+G\+\_\+\+M\+AX (if limits.\+h is included) or 0xffffffff\+UL (if limits.\+h is not included) will have the effect of resetting the task\textquotesingle{}s notification value to 0. Setting ul\+Bits\+To\+Clear\+On\+Entry to 0 will leave the task\textquotesingle{}s notification value unchanged.\\
\hline
{\em ul\+Bits\+To\+Clear\+On\+Exit} & If a notification is pending or received before the calling task exits the x\+Task\+Notify\+Wait() function then the task\textquotesingle{}s notification value (see the x\+Task\+Notify() A\+PI function) is passed out using the pul\+Notification\+Value parameter. Then any bits that are set in ul\+Bits\+To\+Clear\+On\+Exit will be cleared in the task\textquotesingle{}s notification value (note $\ast$pul\+Notification\+Value is set before any bits are cleared). Setting ul\+Bits\+To\+Clear\+On\+Exit to U\+L\+O\+N\+G\+\_\+\+M\+AX (if limits.\+h is included) or 0xffffffff\+UL (if limits.\+h is not included) will have the effect of resetting the task\textquotesingle{}s notification value to 0 before the function exits. Setting ul\+Bits\+To\+Clear\+On\+Exit to 0 will leave the task\textquotesingle{}s notification value unchanged when the function exits (in which case the value passed out in pul\+Notification\+Value will match the task\textquotesingle{}s notification value).\\
\hline
{\em pul\+Notification\+Value} & Used to pass the task\textquotesingle{}s notification value out of the function. Note the value passed out will not be effected by the clearing of any bits caused by ul\+Bits\+To\+Clear\+On\+Exit being non-\/zero.\\
\hline
{\em x\+Ticks\+To\+Wait} & The maximum amount of time that the task should wait in the Blocked state for a notification to be received, should a notification not already be pending when x\+Task\+Notify\+Wait() was called. The task will not consume any processing time while it is in the Blocked state. This is specified in kernel ticks, the macro pd\+M\+S\+\_\+\+T\+O\+\_\+\+T\+I\+C\+S\+K( value\+\_\+in\+\_\+ms ) can be used to convert a time specified in milliseconds to a time specified in ticks.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If a notification was received (including notifications that were already pending when x\+Task\+Notify\+Wait was called) then pd\+P\+A\+SS is returned. Otherwise pd\+F\+A\+IL is returned.
\end{DoxyReturn}
task. h 
\begin{DoxyPre}void vTaskNotifyGiveFromISR( TaskHandle\_t xTaskHandle, BaseType\_t *pxHigherPriorityTaskWoken );\end{DoxyPre}



\begin{DoxyPre}configUSE\_TASK\_NOTIFICATIONS must be undefined or defined as 1 for this macro
to be available.\end{DoxyPre}



\begin{DoxyPre}When configUSE\_TASK\_NOTIFICATIONS is set to one each task has its own private
"notification value", which is a 32-bit unsigned integer (uint32\_t).\end{DoxyPre}



\begin{DoxyPre}A version of xTaskNotifyGive() that can be called from an interrupt service
routine (ISR).\end{DoxyPre}



\begin{DoxyPre}Events can be sent to a task using an intermediary object.  Examples of such
objects are queues, semaphores, mutexes and event groups.  Task notifications
are a method of sending an event directly to a task without the need for such
an intermediary object.\end{DoxyPre}



\begin{DoxyPre}A notification sent to a task can optionally perform an action, such as
update, overwrite or increment the task's notification value.  In that way
task notifications can be used to send data to a task, or be used as light
weight and fast binary or counting semaphores.\end{DoxyPre}



\begin{DoxyPre}vTaskNotifyGiveFromISR() is intended for use when task notifications are
used as light weight and faster binary or counting semaphore equivalents.
Actual FreeRTOS semaphores are given from an ISR using the
xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
a task notification is vTaskNotifyGiveFromISR().\end{DoxyPre}



\begin{DoxyPre}When task notifications are being used as a binary or counting semaphore
equivalent then the task being notified should wait for the notification
using the ulTaskNotificationTake() API function rather than the
xTaskNotifyWait() API function.\end{DoxyPre}



\begin{DoxyPre}See \href{http://www.FreeRTOS.org/RTOS-task-notifications.html}{\tt http://www.FreeRTOS.org/RTOS-task-notifications.html} for more details.\end{DoxyPre}



\begin{DoxyPre}
\begin{DoxyParams}{Parameters}
{\em xTaskToNotify} & The handle of the task being notified.  The handle to a
task can be returned from the xTaskCreate() API function used to create the
task, and the handle of the currently running task can be obtained by calling
xTaskGetCurrentTaskHandle().\\
\hline
{\em pxHigherPriorityTaskWoken} & vTaskNotifyGiveFromISR() will set
*pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
task to which the notification was sent to leave the Blocked state, and the
unblocked task has a priority higher than the currently running task.  If
vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
should be requested before the interrupt is exited.  How a context switch is
requested from an ISR is dependent on the port - see the documentation page
for the port in use.
\\
\hline
\end{DoxyParams}
\end{DoxyPre}
